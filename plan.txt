
- Javascript (только Конфур)
    С чего начинается SPA? Да, с того что нам надо писать на javascript. Все ненавидят JavaScript. Причин много, но всё можно выразить в простой фразе: javascript - это как C++, только хуже. Поэтому люди хотят придумать разумные ограничения. Делают всякие фреймворки, вот и мы рассмотрим некоторые способы ограничитить себя и написать таки на js сложное приложение.

- React
    Мы выбрали реакт, и я не уверен в том что это не полностью осознанный выбор. У меня не так много времени чтобы рассказывать что это такое, поэтому обойдусь парой тезисов.
- React - это не фреймворк
    Да, это не фреймворк. Но зато на нём, можно писать клёвый код с компонентами. Вот у нас есть div, span-ы, а мы можем объявить свой компонент, типа сделать красивый инпут и вставить его.
- Пример с этой презентацией

- React -- это как php, только javascript
    Что мы делали на пхп. Ну во первых, в дальние 90е верстка жила вместе с логикой. Рисовали страничку -- отправляли на клиента. Клиент жал кнеопку субмит, всё это добро уходило на сервер, там крутились шестерни, после этого сервер рисовал станичку заново и мы видели резульзтат.
    Тут происходит тоже самое только перерисовывание мы делаем на каждое действие. Поставил польз... (по то что он жмёт кнопку и мы полностью перерисовываем предтавление) и. Это, конечно, страшно неэффективно, все знают, что работа с домом медленная
- Virtual DOM
    Только разработчики сделали финт ушами -- мол, перерисовывать дом сложно, пусть компоненты рисуют не настоящий дом, а виртуальный -- мы его сравним с последним нарисованным виртуальным домом  и применим измнениия к настоязему дому. И внезапно оказалось, что это работает. В этом смысле работать с версткой очень удобно. View является чистой функцие от модели. Теперь не надо всей это суеты с домом, просто верстаем наш компонент во всех возможных состояниях, а реакт всё сделает сам.
- Картинка с кучей разных библиотек
    Тут люди поняли что хорошобы отделить стейт от представления. Это поняли ещй и тогда когда все писали на пхп и там появились всяки шаблонизацторы для пхп. Мне удалось выделить
- Flux-подобные библиотеки, Различные подписовчные
    Среди всех этих библиотек есть некотрое деление, (туду: отметить что такое flux и subscriptions бибилиотеки)
- Redux
    Мы в итоге выбрали редакс, и я не уверен в том что это разумный выбор. Опять же времени не так много, чтобы рассказать что это такое, но давайте вкратце можно посмотреть.
- Картинка 1
    Мы уже знаем что View - это чистая функция от модели. Из неё вылетают экшины, что пользователь что-то сделал. Редакс, говорит нам, давай те все эти экшины засунем в общую щину и потом что-нибудь с ними сделаем. Далее нам говорят, пусть у нас будет состояние - глобальным объектом, а мы будем писать функции которые возьмут на вход состояние, акшин из шины и выдадут новый стейт. Мы возьмем его и с ним отрисуем View.
    Как это выглядит в код
- dispath во view
    где-то во вью вы делаете диспатч.
- action
    Этот акшин летит в шину
- reducer
    И редьюсер обрабатывает это действие
- dispath во view
    И вью снова его перерисовывает. Я думаю все начинающие (да и не начинающие сталкивались с такой проблемой. Заходишь в инпут жмешь, а ничего не проиходит. Инпут остаётся пустым.)
    На самом деле это впечатляющая концепция: какие у нас есть позитивные моменты:
- Pros, нет манипуляция с домом, предсказуемость
    Поскольку View - чистая функция, то у вас нет манипуляция с домом, есть только дом отрисованные с заданным состоянием,
    Reducer - это чистая функция. Код управление состоянием писать легко - это просто функция с четким набором параметров. Её легко тестировать, она предсказуема. Тут автоматически появляется волшебная фича: тайм тревелинг. Все приложение представляет собой поток акшинов и серию соотв. измененией состояния. В каждом состоянии приложение всегда отрисуется одинаково. Это очень круто. Однако не может быть всё так хорошо.

- картинка 1528
    Когда я решил написать простойшей демо приложение на стеке редакс+реакт я наткнулся на непробиваемую стену из нескольких проблем. Самое ужасное что гугление ничего не давало. В тот момент мы чуть не отказались от этого стека. (туду Зерачим сюда список проблем), Но в конечном счёте тот самый человек признал проблему и опубликовал вот такое сообщение, этот треб прилично вырос, и там есть некоторое количство дельных идей.
- Композиция и инкапсуляция
    Это самое элементарное действие, которое хочется делать если вы пишите бизнес-лапшу. Очень сложно дать точное определение бизнес-лапши, но кажется что все на каком-то уровне понимает это. И так, какие инструменты есть для композиции в нашем стеке.
- Вложенные view
    Обычное приложение выглядит как-то так. У вас есть куча компонент, которые вы вкладываете (то есть композируете) друг в друга и хотите каждую компоненту писать независимо (то есть инкапсулировать её логику). Если с вкладыванием представление всё понятно, это есть бу дизайн в реакте, то что делать с reducer-ами нет. Особенно с акшинами. Например вы написали view, которая должна позволять редактировать персональные данные. Вы честно задиспатчили акшина Change.
- Вот такой.
    И теперь этот акшин надо обработать в редьюсере.
- редьюсер:
    И написали редьюсер. Вот такой. И теперь пришла пора переиспользовать этот код. Самая очевидная идея вот такая.
- Картинка
    Когда вы вкладываете компоненты друг в друга надо просто добавить префикс ко всем экшинам, которые будут выледать из вложенного вью и так далее
    А когда вы вкладываете редьюсеры друг в друга соотв. префикс отрезать.
- Код.
    В целом в библиотеке есть несколько конструкций, которые позволяеют это сделать. Простейшая функция forwardTo для View. И Конструктор reducers-ов. Вот такой, при композиции редьюсеров мы просто указываем с каким под состоянием будет работать вложенные редьюсер и акшины с какми префиксом в него направить. /* Идея крайне простая и заимствована из фреймворка Elm. */

    В целом картинка получается примерно такая:
- Картинка
    Можно просто рассматривать компонент как пару reducer-view и композиция компонент будет сводится к композиции редьюсера и соотв. view/

- Long-running transactions
    Следующая проблема. Лонг ранниг транзакции. Вообще когда у вас все компоненты системы представляют собой чистые функции жить становиться сложнее. Для того чтобы понять в чём вообще дело, давайте рассмотрим проблему.
- Проблема окна подтверждения
    И так я хочу перед тем как пользователь что-то сделает показать ему окно подтверддения. Очень простая задача.
- Код иф то тогда сё
    В идеале я хотел бы написать вот такой код. В целом, задачу отображение окна подтверждения можно решить, но у решений обязательно будут какие-либо недостатки. И вообще, проблема окна подтверждения сделана для того чтобы отразить суть проблемы написания бизнес-лапши. Вот это отрывок -- это сферическая бизнес-лапша. И очень хочется чтобы решение выглядела именно таким образом. Потому что если вы не можете написать такой код для такого просто диалога, то сделать, скажем, визард... будет очень трудно. Кто-то может сказать, что при программирование интерфейсов вообще нельзя написать такой код. Ведь там как ни крути надо вывести окно, потом подписаться на
    нажатие кнопки. Код обязательно будет разнесён на части. Но это не так.
- JQuery код
    Если вы пишите на чем-нибудь другом, то у вас нет такой проблемы, например
    вы можете легко написать вот такой код.
- JQuery code with await async
    Или даже такой если используете последние транспайлеры Javascript.
- Saga
    Из глубин прошлого к нам пришло такое понятие как сага. Первое упоминание об этом паттерне, которое я увидел датировано 1987 годом. Это понятие применимо к системам, которые построены на событиях. Идея, перефразированная на язык react-redux парадигмы, такова: давайте сделаем конечный автомат и запустим его поверх нашей шины событий. Мы сможем ожидать каких-нибудь событий, диспатчить другие события, в зависимости от того что было ранее.
- псевдно код
    Псевдо код саги может выглядеть так. Диспатчим акшин такойто, после этого ожидаем появление такого или такого экшина, в зависимости и того что случилось делаем либо а либо ничего,
- redux-saga
    (Тут нет перехода), Это самая известная реализаци этого паттерна для redux. Вы просто берёте и пишете вот такой код.
- код
    Этот код выглядит немного непривычно, используеются какие-то yield-ы. Но посколько сага -- это конечный автомат, на самом ниском уровне это должно выглядеть именно так. Код, выполняющий сагу просто запрашивает следующий шаг и исполняет его. Состояние конечного автомата хранится по сути в стеке этой процедуры. А сама сага -- это просто генератор.
- код запуска саги
    Однако есть проблема: композировать саги очень сложно. Это код запуска саги: это просто процедура которая запускается на верхнем уровне приложениея, и работает. Представим что вы делаете форму с кнопкой очистить и это компонент со своим поведением, который используется в несколькихз частях вашего приложения. Во-первых вам надоа запусктиьт несколько саг, а во вторых не забыть про профексы экшинов.
- Reelm
    У нас уже есть две точки, вкоторых мы делаем композицию: редьюсеры и view. Есть очень простая идея: пусть редьюсер наряду со state-ом будет выдавать генератор, который и будет запускаться.
- code
    В коде это будет выглядеть как-то так. Всё очень просто. Читаемо. Кроме того редьюсеры, остались по сути чистой фукнцией: на один и тот же набор входных параметров отдаёю тот же резуольтат.

- Управление побочными эффектами
    Последния проблема, с которой вы столкнётесь -- это управление побочными эффектами. Если посмотреть на то, что я рассказывал ранее, в парадигдме реакт-редакс нет места побочным эффектам, кроме тех, которые производит пользователь: жмёт на кнопки. Но мы-то наверно хотим насерверх сходит там, миожет что-то с локал сторадж сложить. А у нас есть только чистые view и reducers. На самом деле я немного недоговорил. Библиотека редакс даёт нам пару мест где можно произвести сайд эффекты
- Картинка с миддллевари и акшин креаторы
    Акшин креаторы, которые стоят пере трубой с экшинами и миддлеваре, которые находятся после трубы. Почему я про них ничего не сказал: да потому, Если редьюсеры и view -- это очень чёткие и понятные концепции, то это места для размещения костылей оставленные разработчикамю. По сути туда и предлагается складывать сайд эффекты. Но есть проблема: код, которые там живёт не потдаётся композиции.
    Но у нас уже есть нсколько скомпозированных сущностей: это "редьюсеры". В них мы генеруем саги. В сагах можно произвести сайд эффект. Например так.
- код выброса сайд эффекта и рядом его обработка.
    Давайте вернёмся, к начальному примеру. А что если нам надо не просто показать окно подтверждения, а иметь там галочку больше не спрашивать. И ещё очень хочется, чтобы компонент, который хочет подтверждения от пользователя не думал обо всё этом. Вообще можно обозвать запрос подтверждения сайд эффектом и просто сгенерировать. А посколько редьюсеры -- это просто композция функций, то объемлющий редьюсер может взять генератор от дочернего редьюсера и как-то его модифицировать, ибо сага -- это просто поток каких-то плайн объектов.

- на работу с сагами можно посмотреть по другим углом?
